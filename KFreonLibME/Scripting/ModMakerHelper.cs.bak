using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using BitConverter = KFreonLibGeneral.Misc.BitConverter;
using Gibbed.IO;
using KFreonLibGeneral.Debugging;
using KFreonLibME.Textures;
using KFreonLibME.MEDirectories;
using System.Collections.ObjectModel;
using System.Windows.Media.Imaging;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Windows.Threading;
using System.Windows;
using System.Collections.Specialized;
using System.Reflection;
using System.Windows.Input;
using KFreonLibME.GUI;
using UsefulThings;
using ResILWrapper;
using System.Diagnostics;
using System.Runtime;

namespace KFreonLibME.Scripting
{
    public class ModMakerViewModel : INotifyPropertyChanged
    {
        #region Properties, etc
        #region State properties
        bool loaded = false;
        public bool Loaded
        {
            get 
            { 
                return loaded; 
            }
            set
            {

                loaded = value;
                OnPropertyChanged();
            }
        }

        bool busy = false;
        public bool Busy
        {
            get
            {
                return !busy;
            }
            set
            {
                busy = value;
                OnPropertyChanged();
            }
        }
        #endregion


        #region Progress properties
        int primaryprogress = -1;
        public int PrimaryProgress
        {
            get
            {
                return primaryprogress;
            }
            set
            {
                primaryprogress = value;
                OnPropertyChanged();
            }
        }

        int maxprimary = 1;
        public int MaxPrimaryProgress
        {
            get
            {
                return maxprimary;
            }
            set
            {
                maxprimary = value;
                OnPropertyChanged();
            }
        }

        int secondary = -1;
        public int SecondaryProgress
        {
            get
            {
                return secondary;
            }
            set
            {
                secondary = value;
                SecondaryVisible = secondary > -1;
                OnPropertyChanged();
            }
        }

        int maxsecondary = -1;
        public int MaxSecondaryProgress
        {
            get
            {
                return maxsecondary;
            }
            set
            {
                maxsecondary = value;
                OnPropertyChanged();
            }
        }

        bool indeterminate = false;
        public bool PrimaryIndeterminate
        {
            get
            {
                return indeterminate;
            }
            set
            {
                indeterminate = value;
                OnPropertyChanged();
            }
        }
        #endregion


        #region Status properties
        string primarystatus = null;
        public string PrimaryStatus
        {
            get
            {
                return primarystatus;
            }
            set
            {
                primarystatus = value;
                OnPropertyChanged();
            }
        }

        string secondarystatus = null;
        public string SecondaryStatus
        {
            get
            {
                return secondarystatus;
            }
            set
            {
                secondarystatus = value;
                OnPropertyChanged();
            }
        }
        #endregion 


        #region Visibility properties
        bool secondaryvisible = false;
        public bool SecondaryVisible
        {
            get
            {
                return secondaryvisible;
            }
            set
            {
                secondaryvisible = value;
                SecondaryVisibility = secondaryvisible ? Visibility.Visible : Visibility.Collapsed;
                OnPropertyChanged();
            }
        }

        Visibility secondaryvisibility = Visibility.Collapsed;
        public Visibility SecondaryVisibility
        {
            get
            {
                return secondaryvisibility;
            }
            set
            {
                secondaryvisibility = value;
                OnPropertyChanged();
            }
        }
        #endregion


        #region Pathing
        MEDirectories.MEDirectories MEExDirecs = new MEDirectories.MEDirectories();
        List<string> BIOGames
        {
            get
            {
                return MEExDirecs.BIOGames;
            }
        }

        string ExecFolder
        {
            get
            {
                return MEExDirecs.ExecFolder;
            }
        }

        bool game1exist = false;
        public bool DoesGame1Exist
        {
            get
            {
                return game1exist;
            }
            set
            {
                game1exist = value;
                OnPropertyChanged();
            }
        }

        bool game2exist = false;
        public bool DoesGame2Exist
        {
            get
            {
                return game2exist;
            }
            set
            {
                game2exist = value;
                OnPropertyChanged();
            }
        }

        bool game3exist = false;
        public bool DoesGame3Exist
        {
            get
            {
                return game3exist;
            }
            set
            {
                game3exist = value;
                OnPropertyChanged();
            }
        }
        
        #endregion


        #region Misc
        private bool thumbsEnabled = true;
        public bool ThumbsEnabled
        {
            get
            {
                return thumbsEnabled;
            }
            set
            {
                thumbsEnabled = value;
                OnPropertyChanged();
            }
        }
        public ObservableCollection<int> GameVersions { get; set; }

        // KFreon: Current mod data variable. So now data doesn't have to get written to disk several times.
        public byte[] ModData { get; set; }

        public string Version
        {
            get
            {
                return "Version: " + Assembly.GetExecutingAssembly().GetName().Version.ToString();
            }
        }

        public int NumMods
        {
            get
            {
                return LoadedMods.Count;
            }
        }

        public FastObservableCollection<KFreonLibME.Scripting.ModMaker.ModJob> LoadedMods { get; set; }
        #endregion


        #region Commands
        public bool CanExecute = true; // KFreon: True for now

        private ICommand _updateCommand;
        public ICommand UpdateCommand
        {
            get
            {
                return _updateCommand ?? (_updateCommand = new CommandHandler(async job =>
                {
                    MaxPrimaryProgress = 1;
                    PrimaryProgress = 0;
                    await Task.Run(() => ((KFreonLibME.Scripting.ModMaker.ModJob)job).UpdateJob(BIOGames, ExecFolder, PrimaryStatusReporter));
                    PrimaryProgress = 1;
                }, CanExecute));
            }
        }

        private ICommand _extractCommand;
        public ICommand ExtractCommand
        {
            get
            {
                return _extractCommand ?? (_extractCommand = new CommandHandler(async job =>
                {
                    MaxPrimaryProgress = 1;
                    PrimaryProgress = 0;
                    PrimaryStatus = "Extracting Job data...";
                    
                    // KFreon: Save pathing
                    KFreonLibME.Scripting.ModMaker.ModJob j = ((KFreonLibME.Scripting.ModMaker.ModJob)job);

                    Microsoft.Win32.SaveFileDialog sfd = new Microsoft.Win32.SaveFileDialog();
                    sfd.Title = "Select destination for data";
                    sfd.Filter = j.JobType == "TEXTURE" ? "DirectX images|*.dds" : "Meshes|*.mesh";
                    if (sfd.ShowDialog() == true)
                    {
                        await Task.Run(() => j.ExtractData(sfd.FileName));
                        PrimaryStatus = "Job data extracted!";
                    }
                    else
                        PrimaryStatus = "Extraction cancelled.";

                    PrimaryProgress = 1;
                }, CanExecute));
            }
        }

        private ICommand _runCommand;
        public ICommand RunCommand
        {
            get
            {
                return _runCommand ?? (_runCommand = new CommandHandler(async job =>
                {
                    MaxPrimaryProgress = 1;
                    PrimaryProgress = 0;


                    int whichGame = -1;
                    string biogame = null;
                    string DLCPath = null;

                    PrimaryStatus = "Installing job...";
                    PrimaryIndeterminate = true;
                    List<string> DLCPCCs = await Task.Run(() => ((KFreonLibME.Scripting.ModMaker.ModJob)job).RunJob(out whichGame));
                    biogame = BIOGames[whichGame - 1];
                    DLCPath = MEExDirecs.GetDifferentDLCPath(whichGame);

                    PrimaryStatus = "Updating TOC's...";


                    await Task.Run(() => KFreonLibME.Helpers.Methods.UpdateTOCs(biogame, whichGame, DLCPath, DLCPCCs));
                    PrimaryIndeterminate = false;
                    PrimaryProgress = 1;

                    PrimaryStatus = "Update Complete!";
                }, CanExecute));
            }
        }

        private ICommand _resetScriptCommand;
        public ICommand ResetScriptCommand
        {
            get
            {
                return _resetScriptCommand ?? (_resetScriptCommand = new CommandHandler(job =>
                {
                    MaxPrimaryProgress = 1;
                    PrimaryProgress = 0;
                    ((KFreonLibME.Scripting.ModMaker.ModJob)job).ResetScript();
                    PrimaryProgress = 1;
                }, CanExecute));
            }
        }

        private ICommand _saveModCommand;
        public ICommand SaveModCommand
        {
            get
            {
                return _saveModCommand ?? (_saveModCommand = new CommandHandler(async job =>
                {
                    MaxPrimaryProgress = 1;
                    PrimaryProgress = 0;
                    PrimaryIndeterminate = true;

                    PrimaryStatus = "Saving job to file...";

                    Microsoft.Win32.SaveFileDialog sfd = new Microsoft.Win32.SaveFileDialog();
                    sfd.Title = "Select destination";
                    sfd.Filter = "ME3 Mods|*.mod";
                    if (sfd.ShowDialog() == true)
                    {
                        if (await Task.Run(() => ModMaker.WriteJobToFile(sfd.FileName, (KFreonLibME.Scripting.ModMaker.ModJob)job)))
                            PrimaryStatus = "Job saved!";
                        else
                            PrimaryStatus = "Saving failed!";
                    }
                    else
                        PrimaryStatus = "Cancelled!";

                    PrimaryIndeterminate = false;
                    PrimaryProgress = 1;

                }, CanExecute));
            }
        }
        #endregion


        #region Callback reporters
        Action<int> PrimaryProgReporter;
        Action<int> SecondaryProgReporter;
        Action<int> PrimaryMaxReporter;
        Action<int> SecondaryMaxReporter;

        Action<string> PrimaryStatusReporter;
        Action<string> SecondaryStatusReporter;
        #endregion


        List<ICommand> Commands = null;
        #endregion




        public ModMakerViewModel()
        {
            LoadedMods = new FastObservableCollection<KFreonLibME.Scripting.ModMaker.ModJob>();
            GameVersions = new ObservableCollection<int>() { 1, 2, 3 };
            

            // KFreon: Ridiculous delegation of progress reports due to being unable to pass properties by ref
            PrimaryProgReporter = new Action<int>(val => PrimaryProgress = val);
            SecondaryProgReporter = new Action<int>(val => SecondaryProgress = val);

            PrimaryMaxReporter = new Action<int>(pm => MaxPrimaryProgress = pm);
            SecondaryMaxReporter = new Action<int>(sm => MaxSecondaryProgress = sm);

            PrimaryStatusReporter = new Action<string>(rep => PrimaryStatus = rep);
            SecondaryStatusReporter = new Action<string>(rep => SecondaryStatus = rep);

            PrimaryStatus = "Ready.";
            Loaded = NumMods > 0;
            KFreonLibME.Scripting.ModMaker.Instance = this;

            // KFreon: Set existence properties - can't be automatic as when they change, the GUI won't be updated
            DoesGame1Exist = MEExDirecs.DoesGame1Exist;
            DoesGame2Exist = MEExDirecs.DoesGame2Exist;
            DoesGame3Exist = MEExDirecs.DoesGame3Exist;

            Commands = new List<ICommand>() { UpdateCommand, ExtractCommand, SaveModCommand, ResetScriptCommand, RunCommand };
        }

        public async void LoadMods(string[] filenames)
        {
            Loaded = false;
            Busy = true;
            if (NumMods == 0)
                KFreonLibME.Scripting.ModMaker.Initialise();

            PrimaryProgress = 0;
            MaxPrimaryProgress = filenames.Count();
            for (int i = 0; i < filenames.Count(); i++)
            {
                string file = filenames[i];
                PrimaryStatus = "Loading " + (i+1) + " of " + filenames.Count() + " mods.";
                Debug.WriteLine("before loading");
                Debug.WriteLine("Virtual: " + Process.GetCurrentProcess().VirtualMemorySize64);
                Debug.WriteLine("Working: " + Process.GetCurrentProcess().WorkingSet64.ToString());
                bool? AutoUpdate = await Task<bool>.Run(() => KFreonLibME.Scripting.ModMaker.LoadDotMod(file, false, SecondaryProgReporter, SecondaryMaxReporter, SecondaryStatusReporter, Commands, ExecFolder, BIOGames, ThumbsEnabled));


                PrimaryProgress++;
            }
            SecondaryProgress = -1;
            Loaded = true;
            Busy = false;
            PrimaryStatus = "Loading complete!";
        }

        public event PropertyChangedEventHandler PropertyChanged;

        public virtual void OnPropertyChanged([CallerMemberName] string propertyname = null)
        {
            if (PropertyChanged != null)
                PropertyChanged(this, new PropertyChangedEventArgs(propertyname));
        }

        public void DeleteJob(int index)
        {
            ModMaker.JobList.RemoveAt(index);

            // KFreon: Reset things if necessary
            if (NumMods == 0)
            {
                PrimaryProgress = 0;
                PrimaryStatus = "Ready.";
                Loaded = false;
                Busy = false;
            }
        }

        public void ClearJobs()
        {
            // KFreon: Reset everything
            ModMaker.JobList.Clear();
            PrimaryProgress = 0;
            PrimaryStatus = "Ready.";
            Loaded = false;
            Busy = false;
        }

        public bool MoveJobDown(int index)
        {
            return MoveJob(index, index + 1);
        }

        public bool MoveJobUp(int index)
        {
            return MoveJob(index, index - 1);
        }

        private bool MoveJob(int from, int to)
        {
            // KFreon: Check validity
            if (from < 0 || from >= LoadedMods.Count || to < 0 || to > LoadedMods.Count - 1)
                return false;

            KFreonLibME.Scripting.ModMaker.ModJob job = LoadedMods[from];
            LoadedMods.RemoveAt(from);
            LoadedMods.Insert(to, job);
            return true;
        }

        public void UpdateJobs()
        {
            throw new NotImplementedException();
        }

        public List<string> RunJob(int index, out int whichGame, out string biogame, out string DLCPath)
        {
            PrimaryStatus = "Installing job...";
            PrimaryIndeterminate = true;
            List<string> DLCPCCs = LoadedMods[index].RunJob(out whichGame);
            biogame = BIOGames[whichGame - 1];
            DLCPath = MEExDirecs.GetDifferentDLCPath(whichGame);
            PrimaryStatus = "Finished!";
            PrimaryIndeterminate = false;
            return DLCPCCs;
        }

        public Dictionary<int, List<string>> RunJobs(out List<string> biogames, out List<string> DLCPaths)
        {
            Dictionary<int, List<string>> updates = new Dictionary<int, List<string>>();
            MaxPrimaryProgress = LoadedMods.Count;

            biogames = BIOGames;
            DLCPaths = MEExDirecs.GetDLCsAsList();

            for (int i = 0; i < LoadedMods.Count; i++)
            {
                PrimaryStatus = "Installing job " + (i + 1) + " of " + LoadedMods.Count;
                PrimaryProgress = i;
                KFreonLibME.Scripting.ModMaker.ModJob job = LoadedMods[i];
                int whichgame = 0;
                List<string> pccs = job.RunJob(out whichgame);

                if (updates.ContainsKey(whichgame))
                {
                    List<string> val = updates[whichgame];
                    val.AddRange(pccs);
                    updates[whichgame] = val.Distinct().ToList();
                }
            }
            PrimaryStatus = "Finished!";
            PrimaryProgress = MaxPrimaryProgress;
            return updates;
        }

        public void SaveJobToMod(int index, string filename)
        {
            PrimaryStatus = "Saving job...";
            PrimaryIndeterminate = true;
            bool res = ModMaker.WriteJobToFile(filename, LoadedMods[index]);
            PrimaryStatus = res ? "Job saved!" : "Saving failed!";
            PrimaryIndeterminate = false;
        }

        public void ResetScript(int index)
        {
            LoadedMods[index].ResetScript();
        }

        public void SelectAllPCCs(int index)
        {
            LoadedMods[index].SelectAllPCCs();
        }

        public void RefreshDirecs()
        {
            MEExDirecs.SetupPathing(false);
        }
    }



    public class FastObservableCollection<T> : ObservableCollection<T>
    {
        private readonly object locker = new object();

        /// <summary>
        /// This private variable holds the flag to
        /// turn on and off the collection changed notification.
        /// </summary>
        private bool suspendCollectionChangeNotification;

        /// <summary>
        /// Initializes a new instance of the FastObservableCollection class.
        /// </summary>
        public FastObservableCollection()
            : base()
        {
            this.suspendCollectionChangeNotification = false;
        }

        /// <summary>
        /// This event is overriden CollectionChanged event of the observable collection.
        /// </summary>
        public override event NotifyCollectionChangedEventHandler CollectionChanged;

        /// <summary>
        /// This method adds the given generic list of items
        /// as a range into current collection by casting them as type T.
        /// It then notifies once after all items are added.
        /// </summary>
        /// <param name="items">The source collection.</param>
        public void AddItems(IList<T> items)
        {
            lock (locker)
            {
                this.SuspendCollectionChangeNotification();
                foreach (var i in items)
                {
                    InsertItem(Count, i);
                }
                this.NotifyChanges();
            }
        }

        /// <summary>
        /// Raises collection change event.
        /// </summary>
        public void NotifyChanges()
        {
            this.ResumeCollectionChangeNotification();
            var arg
                 = new NotifyCollectionChangedEventArgs
                      (NotifyCollectionChangedAction.Reset);
            this.OnCollectionChanged(arg);
        }

        /// <summary>
        /// This method removes the given generic list of items as a range
        /// into current collection by casting them as type T.
        /// It then notifies once after all items are removed.
        /// </summary>
        /// <param name="items">The source collection.</param>
        public void RemoveItems(IList<T> items)
        {
            lock (locker)
            {
                this.SuspendCollectionChangeNotification();
                foreach (var i in items)
                {
                    Remove(i);
                }
                this.NotifyChanges();
            }
        }

        /// <summary>
        /// Resumes collection changed notification.
        /// </summary>
        public void ResumeCollectionChangeNotification()
        {
            this.suspendCollectionChangeNotification = false;
        }

        /// <summary>
        /// Suspends collection changed notification.
        /// </summary>
        public void SuspendCollectionChangeNotification()
        {
            this.suspendCollectionChangeNotification = true;
        }

        /// <summary>
        /// This collection changed event performs thread safe event raising.
        /// </summary>
        /// <param name="e">The event argument.</param>
        protected override void OnCollectionChanged(NotifyCollectionChangedEventArgs e)
        {
            // Recommended is to avoid reentry 
            // in collection changed event while collection
            // is getting changed on other thread.
            using (BlockReentrancy())
            {
                if (!this.suspendCollectionChangeNotification)
                {
                    NotifyCollectionChangedEventHandler eventHandler =
                          this.CollectionChanged;
                    if (eventHandler == null)
                    {
                        return;
                    }

                    // Walk thru invocation list.
                    Delegate[] delegates = eventHandler.GetInvocationList();

                    foreach
                    (NotifyCollectionChangedEventHandler handler in delegates)
                    {
                        // If the subscriber is a DispatcherObject and different thread.
                        DispatcherObject dispatcherObject
                             = handler.Target as DispatcherObject;

                        if (dispatcherObject != null
                               && !dispatcherObject.CheckAccess())
                        {
                            // Invoke handler in the target dispatcher's thread... 
                            // asynchronously for better responsiveness.
                            dispatcherObject.Dispatcher.BeginInvoke
                                  (DispatcherPriority.DataBind, handler, this, e);
                        }
                        else
                        {
                            // Execute handler as is.
                            handler(this, e);
                        }
                    }
                }
            }
        }
    }



    /// <summary>
    /// Provides ModMaker and general .mod functions.
    /// </summary>
    public static class ModMaker
    {
        public static List<System.Windows.Media.Brush> brushes = new List<System.Windows.Media.Brush>() { new System.Windows.Media.SolidColorBrush(System.Windows.Media.Colors.Transparent), new System.Windows.Media.SolidColorBrush(System.Windows.Media.Colors.LightCyan) };
        public static string exec;
        static ModMakerViewModel vm;
        public static ModMakerViewModel Instance
        {
            get
            {
                if (vm == null)
                    vm = new ModMakerViewModel();

                return vm;
            }
            set
            {
                vm = value;
            }
        }

        public static FastObservableCollection<ModJob> JobList
        {
            get
            {
                return Instance.LoadedMods;
            }
            set
            {
                Instance.LoadedMods = value;
            }
        }

        readonly static object Locker = new object();


        public static byte[] GetDataFromCache(uint Length, uint Offset)
        {
            byte[] retval = null;
            lock (Locker)
            {
                using (FileStream fs = new FileStream(exec + "ModData.cache", FileMode.Open, FileAccess.Read, FileShare.Read))
                {
                    fs.Seek((long)Offset, SeekOrigin.Begin);
                    retval = fs.ReadBytes(Length);
                }
            }
            return retval;
        }

        public static void WriteDataToCache(ref uint Length, byte[] value, ref uint Offset)
        {
            lock (Locker)
            {
                if (value.Length > Length)
                {
                    using (FileStream fs = new FileStream(exec + "ModData.cache", FileMode.Append, FileAccess.Write))
                    {
                        Offset = (uint)fs.Position;
                        Length = (uint)value.Length;
                        fs.WriteBytes(value);
                    }
                }
                else
                {
                    using (FileStream fs = new FileStream(exec + "ModData.cache", FileMode.Open, FileAccess.Write))
                    {
                        fs.Seek(Offset, SeekOrigin.Begin);
                        Length = (uint)value.Length;
                        fs.WriteBytes(value);
                    }
                }
            }
        }


        /// <summary>
        /// Returns a texture .mod script built from template in exec folder, given pcc's, expID's, texture name, GameVersion, and some extra pathing stuff.
        /// </summary>
        /// <param name="ExecPath">Path to ME3Explorer exec folder.</param>
        /// <param name="pccs">PCC's to be affected by .mod.</param>
        /// <param name="ExpIDs">ExpID's of PCC's of texName to be affected.</param>
        /// <param name="texName">Name of texture to have the .mod edit.</param>
        /// <param name="WhichGame">Number of game texName belongs to.</param>
        /// <param name="pathBIOGame">BIOGame path of game in question.</param>
        /// <returns>Job script based on all the things.</returns>
        public static string GenerateTextureScript(string ExecPath, List<string> pccs, List<int> ExpIDs, string texName, int WhichGame, string pathBIOGame)
        {
            // KFreon: Get game independent path to remove from all pcc names, in order to make script computer independent.  (i.e. relative instead of absolute paths)
            string MainPath = (WhichGame == 1) ? Path.GetDirectoryName(pathBIOGame) : pathBIOGame;

            // KFreon: Read template in from file
            string script;
            using (StreamReader scriptFile = new StreamReader(ExecPath + "TexScript.txt"))
            {
                script = scriptFile.ReadToEnd();
            }

            // KFreon: Set functions to run
            script = script.Replace("**m1**", "AddImage();");
            script = script.Replace("**m2**", "//No images to remove");
            script = script.Replace("**which**", WhichGame.ToString());

            // KFreon: Add pcc's to script
            string allpccs = "";
            foreach (string filename in pccs)
            {
                //string tempfile = Path.Combine(Path.GetFileName(Path.GetDirectoryName(filename)), Path.GetFileName(filename));
                string tempfile = (filename.ToLowerInvariant().Contains(MainPath.ToLowerInvariant())) ? filename.Remove(0, MainPath.Length + 1) : filename;

                //tempfile = ModGenerator.UpdatePathing(filename, tempfile);
                tempfile = tempfile.Replace("\\", "\\\\");
                allpccs += "pccs.Add(\"" + tempfile + "\");" + Environment.NewLine + "\t\t\t";
            }
            script = script.Replace("**m3**", allpccs);

            // KFreon: Add ExpID's to script
            string allIDs = "";
            foreach (int id in ExpIDs)
            {
                allIDs += "IDs.Add(" + id + ");" + Environment.NewLine + "\t\t\t";
            }
            script = script.Replace("**m4**", allIDs);

            // KFreon: Add texture name
            script = script.Replace("**m5**", texName);

            return script;
        }


        /// <summary>
        /// Sets up ModMaker static things, like the JobList.
        /// </summary>
        public static void Initialise()
        {
            exec = Path.Combine(Path.GetDirectoryName(System.Windows.Forms.Application.ExecutablePath), "exec") + "\\";
            BitConverter.IsLittleEndian = true;

            // KFreon: Clear the data cache and check that it exists
            while (true)
            {
                try
                {
                    if (File.Exists(exec + "ModData.cache"))
                        File.Delete(exec + "ModData.cache");
                    using (FileStream fs = new FileStream(exec + "ModData.cache", FileMode.CreateNew, FileAccess.Write))
                    {
                        fs.WriteByte(0x00);
                    }
                    break;
                }
                catch (IOException)
                { System.Threading.Thread.Sleep(50); }
            }
        }


        /// <summary>
        /// This is the object for storing .mod job data. 
        /// </summary>
        public class ModJob : INotifyPropertyChanged
        {
            public class PCCEntry
            {
                public bool Using { get; set; }
                public string File { get; set; }
                public string Display
                {
                    get
                    {
                        return File + "  @ " + ExpID;
                    }
                }
                public int ExpID { get; set; }

                public PCCEntry()
                {
                    Using = true;
                }
            }

            #region Properties

            #region KFreon: ViewModel
            #region Commands
            ICommand updateCommand = null;
            public ICommand UpdateCommand
            {
                get
                {
                    return updateCommand;
                }
                set
                {
                    updateCommand = value;
                    OnPropertyChanged();
                }
            }

            ICommand extractCommand = null;
            public ICommand ExtractCommand
            {
                get
                {
                    return extractCommand;
                }
                set
                {
                    extractCommand = value;
                    OnPropertyChanged();
                }
            }

            ICommand runCommand = null;
            public ICommand RunCommand
            {
                get
                {
                    return runCommand;
                }
                set
                {
                    runCommand = value;
                    OnPropertyChanged();
                }
            }

            ICommand resetScriptCommand = null;
            public ICommand ResetScriptCommand
            {
                get
                {
                    return resetScriptCommand;
                }
                set
                {
                    resetScriptCommand = value;
                    OnPropertyChanged();
                }
            }

            ICommand saveModCommand = null;
            public ICommand SaveModCommand
            {
                get
                {
                    return saveModCommand;
                }
                set
                {
                    saveModCommand = value;
                    OnPropertyChanged();
                }
            }
            #endregion

            public string ViewName
            {
                get
                {
                    return Name + "  --> Size: " + size;
                }
            }

            string siz = null;
            public string size
            {
                get
                {
                    if (siz == null)
                    {
                        // KFreon: Calculate size
                        siz = Length.ToString() + " bytes.";
                        if (Length > 1024)   // KFreon: Kilobyte
                        {
                            double temp = 1024;
                            string ending = " Kilobytes.";
                            if (Length > 1024 * 1024)  // KFreon: Megabytes
                            {
                                temp = 1024 * 1024;
                                ending = " Megabytes.";
                            }

                            string newsize = (Length / temp).ToString();
                            siz = newsize.Substring(0, newsize.IndexOf('.') + 3) + ending;
                        }
                    }
                    return siz;
                }
            }

            bool requires = false;
            public bool RequiresUpdate
            {
                get
                {
                    return requires;
                }
                set
                {
                    requires = value;
                    OnPropertyChanged();
                }
            }

            BitmapImage bmp = null;
            public BitmapImage Thumbnail
            {
                get
                {
                    return bmp;
                }
                set
                {
                    bmp = value;
                    OnPropertyChanged();
                }
            }

            public string Details
            {
                get
                {
                    string message = "Details: " + Environment.NewLine;
                    int pccCount = PCCs.Where(t => !String.IsNullOrEmpty(t.File)).Count();
                    int expIDCount = PCCs.Where(t => t.ExpID != -1).Count();
                    message += "Texname:   " + Texname + Environment.NewLine;
                    message += "Number of ExpID's detected:   " + expIDCount + Environment.NewLine;
                    message += "Number of PCC's detected:   " + pccCount + Environment.NewLine;

                    // KFreon: Check flimsy validity
                    string fail = "";
                    if (expIDCount == 0)
                        fail += "EXPIDS ";

                    if (pccCount == 0)
                        fail += "PCCS ";

                    if (Texname == "")
                        fail += "TEXNAME ";

                    if (WhichGame == -1)
                        fail += "WHICHGAME ";

                    message += "Valid?  " + Valid + "  " + fail;
                    return message;
                }
            }
            #endregion



            string script = null;
            public string Script
            {
                get
                {
                    return script;
                }
                set
                {
                    script = value;
                    OnPropertyChanged();
                }
            }

            public string OriginalScript = null;
            public string Name = null;
            public string ObjectName
            {
                get
                {
                    string retval = Name;
                    if (Name.Contains("Binary"))
                        retval = Name.Split('"')[1].Trim();
                    else
                    {
                        if (Name.Contains(':'))
                            retval = Name.Split(':')[1].Trim();
                        else if (Name.Contains(" in "))
                            retval = Name.Substring(Name.IndexOf(" in ") + 4);
                    }
                    return retval;
                }
            }

            private uint Offset = 0;
            public uint Length = 0;
            public List<PCCEntry> Orig = null;
            public ObservableCollection<PCCEntry> PCCs { get; set; }
            public string Texname = null;
            public string JobType = null;

            int game = -1;
            public int WhichGame
            {
                get
                {
                    return game;
                }
                set
                {
                    game = value;
                    OnPropertyChanged();
                }
            }

            public bool Valid
            {
                get
                {
                    return (PCCs.Where(t => t.ExpID > 0).Count() != 0 || PCCs.Where(y => !String.IsNullOrEmpty(y.File)).Count() != 0 || !String.IsNullOrEmpty(Texname) || WhichGame != -1) && PCCs.Count == 0 ? false : !PCCs[0].File.Contains("sfar");
                }
            }

            // KFreon: Gets and sets data by storing it in a data cache file. Unfortunately, not everyone has 64 bit Windows.
            public byte[] data
            {
                get
                {
                    return ModMaker.GetDataFromCache(Length, Offset);
                }
                set
                {
                    ModMaker.WriteDataToCache(ref Length, value, ref Offset);
                }
            }
            #endregion

            /// <summary>
            /// Constructor. Empty cos things get added dynamically.
            /// </summary>
            public ModJob()
            {
                PCCs = new ObservableCollection<PCCEntry>();
                WhichGame = -1;
                RequiresUpdate = false;
            }

            public ModJob(List<ICommand> commands)
                : this()
            {
                UpdateCommand = commands[0];
                ExtractCommand = commands[1];
                SaveModCommand = commands[2];
                ResetScriptCommand = commands[3];
                RunCommand = commands[4];
            }

            public List<string> GetPCCsAsList(bool OnlyChecked)
            {
                IEnumerable<string> test =
                    from element in PCCs
                    where (OnlyChecked ? element.Using : true)
                    select element.File;

                return test.ToList();
            }

            public List<int> GetExpIDsAsList(bool OnlyChecked)
            {
                IEnumerable<int> test =
                    from element in PCCs
                    where (OnlyChecked ? element.Using : true)
                    select element.ExpID;

                return test.ToList();
            }

            /// <summary>
            /// Write current job to fileStream.
            /// </summary>
            /// <param name="fs">FileStream to write to.</param>
            public bool WriteJobToFile(FileStream fs)
            {
                bool retval = true;
                try
                {
                    // KFreon: Write job name
                    //fs.WriteBytes(BitConverter.GetBytes(Name.Length));
                    fs.WriteValueS32(Name.Length);
                    foreach (char c in Name)
                        fs.WriteByte((byte)c);

                    // KFreon: Write script
                    //fs.WriteBytes(BitConverter.GetBytes(Script.Length));
                    fs.WriteValueS32(Script.Length);
                    foreach (char c in Script)
                        fs.WriteByte((byte)c);

                    // KFreon: Write job data
                    //fs.WriteBytes(BitConverter.GetBytes(data.Length));
                    fs.WriteValueS32(data.Length);
                    fs.WriteBytes(data);
                    retval = true;
                }
                catch (Exception e)
                {
                    DebugOutput.PrintLn("Error writing job: " + Name + " to file: " + fs.Name + " with error: " + e.Message);
                    retval = false;
                }
                return retval;
            }


            /// <summary>
            /// Decides what current job is. If a texture job, returns TEXTURE, else OTHER. For now anyway, likely add mesh detection later.
            /// </summary>
            /// <returns></returns>
            public string DetectJobType()
            {
                string retval;
                if (Script.Contains("Texplorer"))
                    retval = "TEXTURE";
                else
                    retval = "OTHER";
                return retval;
            }


            /// <summary>
            /// Gets details, like pcc's and expID's, from current script and sets local properties.
            /// Properties:
            ///     ExpID's, PCC's, Texname, WhichGame, JobType.
            /// </summary>
            public void GetJobDetails()
            {
                JobType = DetectJobType();

                bool isTexture = JobType == "TEXTURE" ? true : false;
                List<int> ExpIDs = new List<int>(ModMaker.GetExpIDsFromScript(Script, isTexture));
                List<string> pccs = ModMaker.GetPCCsFromScript(Script, isTexture);

                for (int i = 0; i < (pccs.Count > ExpIDs.Count ? pccs.Count : ExpIDs.Count); i++)
                {
                    PCCEntry entry = new PCCEntry();
                    entry.File = pccs.Count <= i ? null : pccs[i];
                    entry.ExpID = ExpIDs.Count <= i ? -1 : ExpIDs[i];
                    if (entry.File == null || entry.ExpID == -1)
                        entry.Using = false;
                    PCCs.Add(entry);
                }

                Texname = ModMaker.GetObjectNameFromScript(Script, isTexture);
                WhichGame = ModMaker.GetGameVersionFromScript(Script, isTexture);

                OriginalScript = Script;
            }


            /// <summary>
            /// Updates current job script to new format. Returns true if all bits to udpdate are found. NOTE that true does not mean updated script works.
            /// </summary>
            /// <param name="BIOGames">List of BIOGame paths for the games. MUST have only 3 elements. Each can be null if game files not found.</param>
            /// <param name="ExecFolder">Path to the ME3Explorer \exec\ folder.</param>
            /// <returns>True if all bits to update are found in current script.</returns>
            public bool UpdateJob(List<string> BIOGames, string ExecFolder, Action<string> StatusReporter)
            {
                StatusReporter("Updating Job: " + Name);
                DebugOutput.PrintLn("Updating Job: " + Name);

                bool retval = true;

                // KFreon: Ensure game target known
                if (WhichGame == -1)
                {
                    DebugOutput.PrintLn("Game target unknown. Searching...");

                    // KFreon: See if given pcc's exist on disk, and if so which game to they belong to. All basegame pcc's must be part of the same game.
                    int game = PCCObjects.Misc.SearchForPCC(null, BIOGames, null, ObjectName, JobType == "TEXTURE", PCCs.ToList());

                    if (game == -1)
                    {
                        DebugOutput.PrintLn("Unable to find pcc's for job: " + Name);
                        retval = false;
                        WhichGame = 0;
                    }
                    else
                        WhichGame = game;
                }
                DebugOutput.PrintLn("Game target: " + WhichGame);

                // KFreon: Return if already failed
                if (!retval)
                {
                    DebugOutput.PrintLn("Update failed for: " + Name + "! Game target undeterminable.");
                    StatusReporter("Update failed! Game target undeterminable.");
                    return retval;
                }


                // KFreon: If texture job, fix pcc pathing.
                string pathBIOGame = WhichGame == 1 ? Path.GetDirectoryName(BIOGames[WhichGame - 1]) : BIOGames[WhichGame - 1];

                // KFreon: Deal with multiple files found during search
                List<string> multiples;
                List<int> MultiInds;

                // KFreon: Must be the same number of pcc's and expID's
                if (PCCs.Where(t => t.ExpID > 0 && t.File != null).Count() == 0)
                    DebugOutput.PrintLn("Job: " + Name + " has " + PCCs.Where(h => h.File != null).Count() + " PCC's and " + PCCs.Where(j => j.ExpID > 0).Count() + " ExpID's. Incorrect, so skipping...");
                else
                {
                    string script = "";
                    ValidateGivenModPCCs(PCCs, ObjectName, pathBIOGame, out multiples, out MultiInds, ref retval, JobType == "TEXTURE");
                    Orig = new List<PCCEntry>(PCCs);

                    // KFreon: Texture job
                    if (JobType == "TEXTURE")
                    {
                        DebugOutput.PrintLn(Name + " is a texture mod.");

                        // KFreon: Get script for job
                        script = ModMaker.GenerateTextureScript(ExecFolder, GetPCCsAsList(false), GetExpIDsAsList(false), Texname, WhichGame, pathBIOGame);
                    }
                    else
                    {
                        // KFreon: HOPEFULLY a mesh mod...
                        DebugOutput.PrintLn(Name + " is a mesh mod. Hopefully...");

                        script = ModMaker.GenerateMeshScript(PCCs[0].ExpID.ToString(), PCCs[0].File);
                    }
                    Script = script;
                }

                RequiresUpdate = !retval;
                DebugOutput.PrintLn((retval ? "Job: " + Name + " updated!" : "Update failed for: " + Name + "! Unable to validate PCC's."));
                StatusReporter((retval ? "Job updated!" : "Update failed. Unable to validate PCC's."));
                return retval;
            }

            public string ExtractData(string filepath)
            {
                try
                {
                    File.WriteAllBytes(filepath, data);
                }
                catch (Exception e)
                {
                    DebugOutput.PrintLn("Saving Job: " + Name + " failed with error: " + e.Message);
                    return e.Message;
                }
                return null;
            }

            public List<string> RunJob(out int whichGame)
            {
                DebugOutput.PrintLn("Installing job: " + Name);

                List<string> DLCPCCs = new List<string>();
                whichGame = WhichGame;

                ScriptCompiler sc = new ScriptCompiler();
                ModMaker.ModData = data;
                sc.rtb1.Text = Script;

                try
                {
                    sc.Compile();
                    foreach (PCCEntry pcc in PCCs)
                    {
                        string dlcname = KFreonLibME.Misc.Methods.GetDLCNameFromPath(pcc.File);
                        if (dlcname != null && dlcname != "" && !DLCPCCs.Contains(dlcname))
                            DLCPCCs.Add(dlcname);
                    }
                }
                catch (Exception e)
                {
                    DebugOutput.PrintLn("Error occured: " + e.Message);
                }
                return DLCPCCs;
            }

            public void ResetScript()
            {
                Script = OriginalScript;
            }

            public void SelectAllPCCs()
            {
                int checkedCount = PCCs.Where(p => p.Using).Count();
                bool state = (checkedCount > (0.5 * PCCs.Count));

                foreach (PCCEntry pcc in PCCs)
                    pcc.Using = state;
            }

            public event PropertyChangedEventHandler PropertyChanged;

            public virtual void OnPropertyChanged([CallerMemberName]string prop = "")
            {
                if (PropertyChanged != null)
                    PropertyChanged(this, new PropertyChangedEventArgs(prop));
            }

            internal void CreateJobThum()
            {
                using (MemoryTributary imgData = new MemoryTributary(data))
                    using (ResILImage img = new ResILImage(imgData))
                        Thumbnail = img.ToImage(width: 64);
            }
        }

        private static void ValidateGivenModPCCs(ObservableCollection<KFreonLibME.Scripting.ModMaker.ModJob.PCCEntry> PCCs, string ObjectName, string pathBIOGame, out List<string> multiples, out List<int> MultiInds, ref bool retval, bool isTexture)
        {
            multiples = new List<string>();
            MultiInds = new List<int>();

            // KFreon: Fix pccs
            for (int i = 0; i < PCCs.Count; i++)
            {
                // KFreon: Test if pcc naming is correct. If not, fix.
                string pcc = PCCs[i].File;
                string test = pcc;
                if (!pcc.Contains(pathBIOGame))
                    test = Path.Combine(pathBIOGame, pcc);

                if (!File.Exists(test))
                    test = PCCObjects.Misc.SearchForPCC(pcc, pathBIOGame, PCCs[i].ExpID, ObjectName, isTexture);

                if (test.Contains("#"))
                {
                    string[] parts = test.Split('#');
                    multiples.AddRange(parts);
                    for (int m = 0; m < parts.Length; m++)
                        MultiInds.Add(i);
                }
                else if (test != "")
                {
                    string temp = test.Remove(0, pathBIOGame.Length + 1);
                    if (!temp.Contains("\\\\"))
                        temp = temp.Replace("\\", "\\\\");
                    PCCs[i].File = temp;
                }
                else
                {
                    DebugOutput.PrintLn("Unable to find path for: " + pcc + ". This WILL cause errors later.");
                    PCCs[i].File = pcc;
                    retval = false;
                }
            }

            // KFreon: Deal with multiples
            if (multiples.Count > 0)
            {
                int found = 0;
                for (int i = 0; i < multiples.Count; i++)
                {
                    // TODO KFREON Need both multiples here
                    string pcc1 = multiples[i];
                    for (int j = i + 1; j < multiples.Count; j++)
                    {
                        string pcc2 = multiples[j];
                        if (pcc1 == pcc2)
                        {
                            found++;

                            if (!pcc1.Contains("\\\\"))
                                pcc1 = pcc1.Replace("\\", "\\\\");

                            PCCs[MultiInds[i]].File = pcc1;
                        }
                    }
                }

                // KFreon: Multiples still unresolved
                if (found != 0)
                {
                    // TODO KFreon add check to look at the given name fisrst. Might have something in it to clarify.
                    // TODO:  KFreon add selection ability
                    DebugOutput.PrintLn("MULTIPLES STILL UNRESOLVED!!!");
                }
            }
        }


        /// <summary>
        /// Create a texture ModJob from a tex2D with some pathing stuff.
        /// </summary>
        /// <param name="tex2D">Texture2D to build job from.</param>
        /// <param name="imgPath">Path of texture image to create job with.</param>
        /// <param name="WhichGame">Game to target.</param>
        /// <param name="pathBIOGame">Path to BIOGame of targeted game.</param>
        /// <returns>New ModJob based on provided image and Texture2D.</returns>
        public static ModJob CreateTextureJob(ITexture2D tex2D, string imgPath, int WhichGame, string pathBIOGame)
        {
            // KFreon: Get script
            string script = GenerateTextureScript(exec, tex2D.allPccs, tex2D.expIDs, tex2D.texName, WhichGame, pathBIOGame);
            ModJob job = new ModJob();
            job.Script = script;

            // KFreon: Get image data
            using (FileStream stream = new FileStream(imgPath, FileMode.Open))
            {
                FileInfo fs = new FileInfo(imgPath);
                byte[] buff = new byte[fs.Length];
                stream.Read(buff, 0, buff.Length);
                job.data = buff;
            }
            job.Name = (tex2D.Mips > 1 ? "Upscale (with MIP's): " : "Upscale: ") + tex2D.texName;
            return job;
        }


        /// <summary>
        /// Writes the first invariable parts of a .mod (version, number of jobs) to FileStream.
        /// </summary>
        /// <param name="fs">FileStream to write to.</param>
        /// <param name="jobcount">Number of jobs. Exists because it's not always JobList.Count.</param>
        public static void WriteModHeader(FileStream fs, int jobcount)
        {
            // KFreon: Write version
            string version = System.Reflection.Assembly.GetExecutingAssembly().GetName().Version.ToString();
            fs.Seek(0, SeekOrigin.Begin);
            //byte[] length = BitConverter.GetBytes(version.Length);
            //fs.WriteBytes(length);
            fs.WriteValueS32(version.Length);
            foreach (char c in version)
                fs.WriteByte((byte)c);

            // KFreon: Write number of jobs to be included in this .mod
            fs.WriteValueS32(jobcount);

            DebugOutput.PrintLn("Version: " + version);
            DebugOutput.PrintLn("Number of jobs: " + jobcount);
        }


        /// <summary>
        /// Gets .mod build version, current toolset build version, and a boolean showing if they match.
        /// Returns: Current toolset version.
        /// Outs: .mod version, bool showing if matching.
        /// </summary>
        /// <param name="version">Version area extracted from .mod. May NOT be version if .mod is outdated.</param>
        /// <param name="newversion">OUT: .mod build version if applicable.</param>
        /// <param name="validVers">OUT: True if .mod supported by current toolset.</param>
        /// <returns>Current toolset build version.</returns>
        private static string GetVersion(string version, out string newversion, out bool validVers)
        {
            validVers = false;

            // KFreon: Get .mod version bits and check if valid version.
            List<string> modVersion = new List<string>(version.Split('.'));
            if (modVersion.Count == 4)
                validVers = true;


            List<string> ExecutingVersion = new List<string>(System.Reflection.Assembly.GetExecutingAssembly().GetName().Version.ToString().Split('.'));
            DebugOutput.PrintLn("Current Version: " + String.Join(".", ExecutingVersion) + "    Mod built with version: " + String.Join(".", modVersion));

            newversion = "";
            try
            {
                modVersion.RemoveAt(modVersion.Count - 1);
                modVersion.RemoveAt(modVersion.Count - 1);
                newversion = String.Join(".", modVersion);
            }
            catch (Exception e)
            {
                DebugOutput.PrintLn("Version parse failed: " + e.Message);
            }


            ExecutingVersion.RemoveAt(ExecutingVersion.Count - 1);
            ExecutingVersion.RemoveAt(ExecutingVersion.Count - 1);

            return String.Join(".", ExecutingVersion);
        }



        public static bool? LoadDotMod(string file, bool ExternalCall, Action<int> ProgReporter, Action<int> MaxProgReporter, Action<string> StatusReporter, List<ICommand> commands, string ExecFolder, List<string> BIOGames, bool thumbsEnabled)
        {
            bool AutoUpdate = false;
            bool requiresUpdate = false;

            // KFreon: Load from file
            using (FileStream fs = new FileStream(file, FileMode.Open, FileAccess.Read))
            {
                // KFreon: Attempt to get version
                fs.Seek(0, SeekOrigin.Begin);
                int versionLength = fs.ReadValueS32();
                long countOffset = fs.Seek(0, SeekOrigin.Current);  // Just in case
                string version = "";
                int count = -1;
                string ExecutingVersion = null;
                bool validVersion = false;
                if (versionLength > 20)     // KFreon: Version is definitely wrong
                    ExecutingVersion = "";
                else
                {
                    // KFreon: Do version checking
                    for (int i = 0; i < versionLength; i++)
                        version += (char)fs.ReadByte();

                    // KFreon: Get Executing Version and check validity of read .mod version
                    string vers;
                    ExecutingVersion = GetVersion(version, out vers, out validVersion);
                    version = vers;

                    count = fs.ReadValueS32();

                    // KFreon: Check if update required
                    if (version != ExecutingVersion)
                    {
                        if (ExternalCall)
                            AutoUpdate = true;
                    }
                    else   // KFreon: Reset to null to signify success
                        ExecutingVersion = null;
                }


                // KFreon: Ask what to do about version
                if (ExecutingVersion != null)
                {
                    

                    DialogResult dr = System.Windows.Forms.MessageBox.Show("This .mod is old and unsupported by this version of ME3Explorer." + Environment.NewLine + "Click Yes to update .mod now, No to continue loading .mod, or Cancel to stop loading .mod", "Ancient .mod detected.", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning);
                    if (dr == System.Windows.Forms.DialogResult.Cancel)
                        return null;
                    else if (dr == System.Windows.Forms.DialogResult.Yes)
                        AutoUpdate = true;


                    requiresUpdate = true;

                    // KFreon: Reset stream position if necessary
                    if (!validVersion)
                    {
                        count = versionLength;
                        fs.Seek(countOffset, SeekOrigin.Begin);
                    }
                }


                // KFreon: Set progress
                MaxProgReporter(count);

                // KFreon: Read Data
                DebugOutput.PrintLn("Found " + count + " Jobs", true);
                for (int i = 0; i < count; i++)
                {
                    StatusReporter("Loading ...  " + (i+1) + " of " + count + ".");
                    ProgReporter(i+1);

                    // KFreon: Read name
                    ModMaker.ModJob md = new ModMaker.ModJob(commands);
                    md.RequiresUpdate = requiresUpdate;
                    int len = fs.ReadValueS32();
                    md.Name = "";
                    for (int j = 0; j < len; j++)
                        md.Name += (char)fs.ReadByte();

                    // KFreon: Read script
                    len = fs.ReadValueS32();
                    md.Script = "";
                    for (int j = 0; j < len; j++)
                        md.Script += (char)fs.ReadByte();

                    // KFreon: Read data
                    len = fs.ReadValueS32();
                    byte[] buff = fs.ReadBytes(len);
                    md.data = buff;

                    // KFreon: Try to get job thumbnail, and get pcc's, etc
                    Debug.WriteLine("before making thumb");
                    Debug.WriteLine("working: " + Process.GetCurrentProcess().WorkingSet64);
                    Debug.WriteLine("virtual: " + Process.GetCurrentProcess().VirtualMemorySize64);
                    if (thumbsEnabled)
                        md.CreateJobThum();
                    md.GetJobDetails();

                    if (AutoUpdate)
                        md.UpdateJob(BIOGames, ExecFolder, StatusReporter);

                    ModMaker.JobList.Add(md);
                    DebugOutput.PrintLn("Add Job \"" + md.Name + "\"", true);
                }
            }
            return AutoUpdate;
        }


        /// <summary>
        /// Returns list of PCC's from job script.
        /// </summary>
        /// <param name="script">Script to search through.</param>
        /// <returns>List of PCC's found in script.</returns>
        public static List<string> GetPCCsFromScript(string script, bool isTexture)
        {
            List<string> lines = new List<string>(script.Split('\n'));
            List<string> pccs = new List<string>();

            // KFreon: Search through script lines
            if (isTexture)
            {
                foreach (string line in lines)
                    if (line.Contains("pccs."))   // KFreon: Only look at pcc lines.
                    {
                        string item = line.Split('"')[1];
                        pccs.Add(item);
                    }


                    else if (line.Contains("public void RemoveTex()"))   // KFreon: Stop at the end of the first section.
                        break;
            }
            else
            {
                string pathing = "";
                foreach (string line in lines)
                {
                    if (line.Contains("string filename = "))
                    {
                        string[] parts = line.Split('=');
                        string pcc = parts[1].Split('"')[1];
                        if (pcc.Contains("sfar"))
                            pcc = "TOO OLD TO FIX";
                        pathing += pcc;
                    }
                    else if (line.Contains("string pathtarget = "))
                    {
                        string[] parts = line.Split('"');
                        string path = "";
                        if (parts.Count() > 1)
                            path = parts[1];
                        pathing = path + pathing;
                    }
                }
                if (pathing != "")
                {
                    pathing = pathing.TrimStart("\\".ToCharArray());
                    /*int ind = pathing.IndexOf("DLC\\");
                    if (ind != -1)
                        pathing = pathing.Substring(ind + 5);*/

                    pccs.Add(pathing);
                }

            }

            return pccs;
        }


        /// <summary>
        /// Returns list of ExpID's from job script.
        /// </summary>
        /// <param name="script">Script to search through.</param>
        /// <returns>List of ExpID's found in script.</returns>
        public static List<int> GetExpIDsFromScript(string script, bool isTexture)
        {
            List<string> lines = new List<string>(script.Split('\n'));
            List<int> ids = new List<int>();

            // KFreon: Search through script lines.
            if (isTexture)
            {
                foreach (string line in lines)
                    if (line.Contains("IDs."))   // KFreon: Only look at ExpID lines.
                        ids.Add(Int32.Parse(line.Split('(')[1].Split(')')[0]));
                    else if (line.Contains("public void RemoveTex()"))   // KFreon: Stop at end of first section.
                        break;
            }
            else
            {
                foreach (string line in lines)
                {
                    if (line.Contains("int objidx = "))
                    {
                        string[] parts = line.Split('=');
                        string number = parts[1].Substring(1, parts[1].Length - 3);
                        ids.Add(Int32.Parse(number));
                        break;
                    }
                }
            }

            return ids;
        }


        /// <summary>
        /// Returns name of texture from job script.
        /// </summary>
        /// <param name="script">Script to search through.</param>
        /// <returns>Texture name found in script.</returns>
        public static string GetObjectNameFromScript(string script, bool isTexture)
        {
            List<string> lines = new List<string>(script.Split('\n'));
            string texname = "";

            // KFreon: Search through lines.
            if (isTexture)
            {
                foreach (string line in lines)
                    if (line.Contains("tex."))  // KFreon: Look for texture name
                        return line.Split('"')[1];
            }
            else
            {
                texname = "Some Mesh";
            }

            return texname;
        }


        /// <summary>
        /// Return which game script is targeting.
        /// </summary>
        /// <param name="script">Script to search through.</param>
        /// <returns>Game version.</returns>
        public static int GetGameVersionFromScript(string script, bool isTexture)
        {
            List<string> lines = new List<string>(script.Split('\n'));
            int retval = -1;

            // KFreon: Search through lines.
            if (isTexture)
            {
                foreach (string line in lines)
                {
                    // KFreon: Look for Texplorer line, which contains game target.
                    if (line.Contains("Texplorer2("))
                    {
                        string[] parts = line.Split(',');
                        int test = -1;
                        if (parts.Length > 1)
                            if (int.TryParse(parts[1].Split(')')[0], out test))
                                retval = test;
                    }
                }
            }
            else
                retval = 3;

            return retval;
        }

        public static void AddJob(ITexture2D tex2D, string ReplacingImage, int WhichGame, string pathBIOGame)
        {
            if (JobList.Count == 0)
                Initialise();
            ModJob job = ModMaker.CreateTextureJob(tex2D, ReplacingImage, WhichGame, pathBIOGame);
            JobList.Add(job);
        }

        public static string GenerateMeshScript(string expID, string pcc)
        {
            string loc = Path.GetDirectoryName(System.Windows.Forms.Application.ExecutablePath);
            string template = System.IO.File.ReadAllText(loc + "\\exec\\JobTemplate_Binary2.txt");
            template = template.Replace("**m1**", expID);
            template = template.Replace("**m2**", pcc);
            //template = template.Replace("**PATH**", pcc.ToUpperInvariant().Contains("DLC_") ? "ME3Directory.DLCPath" : "ME3Directory.cookedPath");
            return template;
        }

        public static ModJob GenerateMeshModJob(string newfile, int expID, string pccname, byte[] data)
        {
            KFreonLibME.Scripting.ModMaker.ModJob mj = new KFreonLibME.Scripting.ModMaker.ModJob();

            // KFreon: Get replacing data
            byte[] buff = null;
            if (data != null)
            {
                FileStream fs = new FileStream(newfile, FileMode.Open, FileAccess.Read);
                buff = new byte[fs.Length];
                int cnt;
                int sum = 0;
                while ((cnt = fs.Read(buff, sum, buff.Length - sum)) > 0) sum += cnt;
                fs.Close();
            }
            else
                buff = data;


            string currfile = Path.GetFileName(pccname);
            mj.data = buff;
            mj.Name = "Binary Replacement for file \"" + currfile + "\" in Object #" + expID + " with " + buff.Length + " bytes of data";
            mj.Script = GenerateMeshScript(expID.ToString(), currfile);
            return mj;
        }

        public static void AddOnUI<T>(this ICollection<T> collection, T item)
        {
            Action<T> addMethod = collection.Add;
            System.Windows.Application.Current.Dispatcher.BeginInvoke(addMethod, item);
        }

        public static byte[] ModData
        {
            get
            {
                return Instance.ModData;
            }
            set
            {
                Instance.ModData = value;
            }
        }

        public static bool WriteJobToFile(string filename, ModJob job)
        {
            bool retval = false;
            DebugOutput.PrintLn("Writing job: " + job.Name + " to file: " + filename);
            using (FileStream fs = new FileStream(filename, FileMode.Create, FileAccess.Write))
            {
                ModMaker.WriteModHeader(fs, 1);
                retval = job.WriteJobToFile(fs);
            }
            return retval;
        }
    }

    public class CommandHandler : ICommand
    {
        private Action<object> _action;
        private bool _canExecute;


        public CommandHandler(Action<object> action, bool canExecute)
        {
            _action = action;
            _canExecute = canExecute;
        }

        public bool CanExecute(object parameter)
        {
            return _canExecute;
        }

        public void Execute(object parameter)
        {
            _action(parameter);
        }

        public event EventHandler CanExecuteChanged;
    }
}
